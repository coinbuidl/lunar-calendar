#[path = "lunar-calendar-data-1900-2099.rs"]
pub mod data;

use crate::data::*;
use chrono::{Datelike, NaiveDateTime, Timelike};

const STEMS: [&str; 10] = ["甲", "乙", "丙", "丁", "戊", "己", "庚", "辛", "壬", "癸"];
const BRANCHES: [&str; 12] = ["子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥"];
const NA_YIN: [&str; 30] = [
    "海中金", "炉中火", "大林木", "路旁土", "剑锋金", "山头火", "涧下水", "城头土", "白蜡金", "杨柳木",
    "泉中水", "屋上土", "霹雳火", "松柏木", "长流水", "沙中金", "山下火", "平地木", "壁上土", "金箔金",
    "覆灯火", "天河水", "大驿土", "钗钏金", "桑柘木", "大溪水", "沙中土", "天上火", "石榴木", "大海水",
];

/// Pillars of a specific date and time.
#[derive(Debug)]
pub struct BaziPillars {
    pub year: String,
    pub month: String,
    pub day: String,
    pub hour: String,
}

impl std::fmt::Display for BaziPillars {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}年 {}月 {}日 {}时", self.year, self.month, self.day, self.hour)
    }
}

/// Converts Gregorian year to a 0..=59 cycle index where 1984 is 甲子 (index 0).
pub fn get_cycle_index(year: i32) -> usize {
    (year - 1984).rem_euclid(60) as usize
}

/// Returns (Heavenly Stem, Earthly Branch) for a 0..=59 cycle index.
pub fn get_stem_branch(index: usize) -> Option<(&'static str, &'static str)> {
    if index >= 60 {
        return None;
    }
    Some((STEMS[index % 10], BRANCHES[index % 12]))
}

/// Helper to get formatted stem-branch string.
fn format_gz(index: usize) -> String {
    let (s, b) = get_stem_branch(index % 60).unwrap();
    format!("{}{}", s, b)
}

/// Returns NaYin for a 0..=59 cycle index.
pub fn get_nayin_by_index(index: usize) -> Option<&'static str> {
    if index >= 60 {
        return None;
    }
    Some(NA_YIN[index / 2])
}

/// Returns NaYin for a Gregorian year using 1984 as 甲子 base.
pub fn get_nayin_by_year(year: i32) -> &'static str {
    let idx = get_cycle_index(year);
    // Safe for 0..=59 indices generated by get_cycle_index.
    NA_YIN[idx / 2]
}

/// Find the year data from the static table.
pub fn get_year_data(year: i32) -> Option<&'static BaziYearData> {
    BAZI_YEAR_DATA.iter().find(|d| d.year == year)
}

/// Information about a specific time point relative to solar terms.
#[derive(Debug)]
pub struct JieQiContext {
    pub prev_name: &'static str,
    pub prev_time: NaiveDateTime,
    pub next_name: &'static str,
    pub next_time: NaiveDateTime,
    pub diff_prev_seconds: i64,
    pub diff_next_seconds: i64,
}

impl std::fmt::Display for JieQiContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let prev_days = self.diff_prev_seconds / 86400;
        let prev_hours = (self.diff_prev_seconds % 86400) / 3600;
        let next_days = self.diff_next_seconds / 86400;
        let next_hours = (self.diff_next_seconds % 86400) / 3600;
        write!(
            f,
            "前气: {} ({}, 距今 {}天{}小时), 后气: {} ({}, 距今 {}天{}小时)",
            self.prev_name, self.prev_time, prev_days, prev_hours,
            self.next_name, self.next_time, next_days, next_hours
        )
    }
}

/// Returns the surrounding JieQi (Solar Terms) for a given timestamp.
pub fn get_jieqi_context(target_time: NaiveDateTime) -> Option<JieQiContext> {
    let year = target_time.date().year();
    
    // We search the current year and the adjacent years to find the bracket
    let mut all_terms: Vec<&JieQiData> = Vec::new();
    
    for y in [year - 1, year, year + 1] {
        if let Some(data) = get_year_data(y) {
            for jq in &data.jieqi {
                all_terms.push(jq);
            }
        }
    }
    
    // Parse strings to dates and sort
    let mut sorted_terms: Vec<(&'static str, NaiveDateTime)> = all_terms.iter()
        .map(|jq| (jq.name, NaiveDateTime::parse_from_str(jq.time, "%Y-%m-%d %H:%M:%S").unwrap()))
        .collect();
    
    sorted_terms.sort_by_key(|t| t.1);
    
    // Find the pair
    for i in 0..sorted_terms.len() - 1 {
        let (name_curr, time_curr) = sorted_terms[i];
        let (name_next, time_next) = sorted_terms[i+1];
        
        if target_time >= time_curr && target_time < time_next {
            return Some(JieQiContext {
                prev_name: name_curr,
                prev_time: time_curr,
                next_name: name_next,
                next_time: time_next,
                diff_prev_seconds: (target_time - time_curr).num_seconds(),
                diff_next_seconds: (time_next - target_time).num_seconds(),
            });
        }
    }
    
    None
}

/// Map Solar Term name to index (0=Lichun, 1=Yushui, ..., 23=Dahan)
fn jieqi_to_index(name: &str) -> Option<usize> {
    let names = [
        "立春", "雨水", "惊蛰", "春分", "清明", "谷雨",
        "立夏", "小满", "芒种", "夏至", "小暑", "大暑",
        "立秋", "处暑", "白露", "秋分", "寒露", "霜降",
        "立冬", "小雪", "大雪", "冬至", "小寒", "大寒",
        "DA_XUE", // alias for data file consistency
    ];
    if name == "DA_XUE" { return Some(20); }
    names.iter().position(|&n| n == name)
}

/// Calculate the pillars for a given date and time.
pub fn get_pillars(dt: NaiveDateTime) -> Option<BaziPillars> {
    let context = get_jieqi_context(dt)?;
    let year_data = get_year_data(dt.year())?;
    
    // 1. Year Pillar (based on Li Chun)
    let lichun = NaiveDateTime::parse_from_str(year_data.lichun_time, "%Y-%m-%d %H:%M:%S").unwrap();
    let bazi_year = if dt < lichun { dt.year() - 1 } else { dt.year() };
    let year_gz = format_gz(get_cycle_index(bazi_year));

    // 2. Month Pillar (based on 12 "Jie")
    // Jie (节) starts a month: 立春, 惊蛰, 清明, 立夏, 芒种, 小暑, 立秋, 白露, 寒露, 立冬, 大雪, 小寒
    let jie_names = ["立春", "惊蛰", "清明", "立夏", "芒种", "小暑", "立秋", "白露", "寒露", "立冬", "DA_XUE", "小寒"];
    
    // Find the current Jie index
    let mut month_idx = 0; // 0 = Yin (Tiger)
    let year = dt.year();
    let mut jies = Vec::new();
    for y in [year - 1, year] {
        if let Some(data) = get_year_data(y) {
            for jq in &data.jieqi {
                if jie_names.contains(&jq.name) {
                    jies.push((jq.name, NaiveDateTime::parse_from_str(jq.time, "%Y-%m-%d %H:%M:%S").unwrap()));
                }
            }
        }
    }
    jies.sort_by_key(|t| t.1);
    
    let mut current_jie_name = "";
    for i in 0..jies.len() {
        if dt >= jies[i].1 && (i + 1 == jies.len() || dt < jies[i+1].1) {
            current_jie_name = jies[i].0;
            month_idx = jie_names.iter().position(|&n| n == current_jie_name).unwrap();
            break;
        }
    }
    
    // Month Stem: (Year Stem index * 2 + Month index + 2) % 10
    let year_stem_idx = (get_cycle_index(bazi_year) % 10) as i32;
    let m_stem_idx = (year_stem_idx * 2 + (month_idx as i32) + 2) % 10;
    let m_branch_idx = (month_idx + 2) % 12; // Yin = 2
    let month_gz = format!("{}{}", STEMS[m_stem_idx as usize], BRANCHES[m_branch_idx]);

    // 3. Day Pillar
    // Base date: 1900-01-01 is 甲戌 (index 10 in cycle)
    let base_date = chrono::NaiveDate::from_ymd_opt(1900, 1, 1).unwrap();
    let diff_days = (dt.date() - base_date).num_days();
    let day_idx = (10 + diff_days).rem_euclid(60) as usize;
    let day_gz = format_gz(day_idx);

    // 4. Hour Pillar
    // Hour Branch: (hour + 1) / 2 % 12
    let h_branch_idx = ((dt.hour() + 1) / 2) % 12;
    // Hour Stem: (Day Stem index * 2 + Hour Branch index) % 10
    let day_stem_idx = (day_idx % 10) as i32;
    let h_stem_idx = (day_stem_idx * 2 + (h_branch_idx as i32)) % 10;
    let hour_gz = format!("{}{}", STEMS[h_stem_idx as usize], BRANCHES[h_branch_idx as usize]);

    Some(BaziPillars {
        year: year_gz,
        month: month_gz,
        day: day_gz,
        hour: hour_gz,
    })
}
