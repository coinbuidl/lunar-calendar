use crate::data::{BAZI_YEAR_DATA, BaziYearData};

pub const MIN_SUPPORTED_YEAR: i32 = 1900;
pub const MAX_SUPPORTED_YEAR: i32 = 2099;

pub(crate) const STEMS: [&str; 10] = ["甲", "乙", "丙", "丁", "戊", "己", "庚", "辛", "壬", "癸"];
pub(crate) const BRANCHES: [&str; 12] = [
    "子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥",
];
const NA_YIN: [&str; 30] = [
    "海中金",
    "炉中火",
    "大林木",
    "路旁土",
    "剑锋金",
    "山头火",
    "涧下水",
    "城头土",
    "白蜡金",
    "杨柳木",
    "泉中水",
    "屋上土",
    "霹雳火",
    "松柏木",
    "长流水",
    "沙中金",
    "山下火",
    "平地木",
    "壁上土",
    "金箔金",
    "覆灯火",
    "天河水",
    "大驿土",
    "钗钏金",
    "桑柘木",
    "大溪水",
    "沙中土",
    "天上火",
    "石榴木",
    "大海水",
];

/// Converts Gregorian year to a 0..=59 cycle index where 1984 is 甲子 (index 0).
pub fn get_cycle_index(year: i32) -> usize {
    (year - 1984).rem_euclid(60) as usize
}

/// Returns (Heavenly Stem, Earthly Branch) for a 0..=59 cycle index.
pub fn get_stem_branch(index: usize) -> Option<(&'static str, &'static str)> {
    if index >= 60 {
        return None;
    }
    Some((STEMS[index % 10], BRANCHES[index % 12]))
}

/// Returns NaYin for a 0..=59 cycle index.
pub fn get_nayin_by_index(index: usize) -> Option<&'static str> {
    if index >= 60 {
        return None;
    }
    Some(NA_YIN[index / 2])
}

/// Returns NaYin for a Gregorian year using 1984 as 甲子 base.
pub fn get_nayin_by_year(year: i32) -> &'static str {
    let idx = get_cycle_index(year);
    // Safe for 0..=59 indices generated by get_cycle_index.
    NA_YIN[idx / 2]
}

/// Find the year data from the static table.
pub fn get_year_data(year: i32) -> Option<&'static BaziYearData> {
    if !(MIN_SUPPORTED_YEAR..=MAX_SUPPORTED_YEAR).contains(&year) {
        return None;
    }
    let idx = (year - MIN_SUPPORTED_YEAR) as usize;
    let row = BAZI_YEAR_DATA.get(idx)?;
    debug_assert_eq!(row.year, year);
    Some(row)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn cycle_index_wraps() {
        assert_eq!(get_cycle_index(1984), 0);
        assert_eq!(get_cycle_index(1985), 1);
        assert_eq!(get_cycle_index(1983), 59);
    }

    #[test]
    fn year_lookup_is_bounded() {
        assert!(get_year_data(1899).is_none());
        assert!(get_year_data(2100).is_none());
        assert_eq!(get_year_data(1900).map(|y| y.year), Some(1900));
        assert_eq!(get_year_data(2099).map(|y| y.year), Some(2099));
    }
}
